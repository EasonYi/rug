import {TextTreeNode} from "../../tree/PathExpression";

/**
 * Extended by classes that know how to handle YAML strings or sequences.
 * We need to transform them on return and on update.
 */
export interface YamlStringOps {

    /**
     * Returns the actual text, not the raw value,
     * which may contain quotes etc.
     */
    text(): string

    /**
     * Update the actual text, taking care of quotes, newlines etc.
     */
    updateText(to: string): void
}

export type YamlString = YamlStringOps & TextTreeNode

/**
 * String without quotes or newlines. Leave it alone.
 */
export class RawValue implements YamlStringOps {

    constructor(private node: TextTreeNode) {
    }

    text() {
        return this.node.value()
    }

    updateText(to: string) {
        this.node.update(to)
    }
}

/**
 * String enclosed in "". Simply strip them.
 */
export class QuotedValue implements YamlStringOps {

    constructor(private node: TextTreeNode) {
    }

    text() {
        return this.node.value().slice(1, this.node.value().length - 1)
    }

    updateText(to: string) {
        let newValue = `"${to}"`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using >. Strip newlines.
 */
export class FoldedBlockScalar implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '>') throw new Error("Illegal argument: Must begin with >")
        if (raw.charAt(1) != '\n') throw new Error("Illegal argument: Must begin with >\n")
        let index = 2
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(2)
    }

    text() {
        return this.node.value().substr(this.leading.length)
                .replace(new RegExp('^' + this.indent, 'mg'), '')
                .replace(new RegExp('\n+$'), '')
                .replace(new RegExp('([^\n])\n([^\n])', 'g'), '$1 $2')
                .replace(new RegExp('\n\n', 'g'), '\n') + '\n'
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using >-.
 */
export class FoldedStripBlockChomping implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '>' && raw.charAt(1) != '-') throw new Error("Illegal argument: Must begin with >-")
        if (raw.charAt(2) != '\n') throw new Error("Illegal argument: Must begin with >-\n")
        let index = 3
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(3)
    }

    text() {
        return this.node.value().substr(this.leading.length)
                .replace(new RegExp('^' + this.indent, 'mg'), '')
                .replace(new RegExp('\n+$'), '')
                .replace(new RegExp('([^\n])\n([^\n])', 'g'), '$1 $2')
                .replace(new RegExp('\n\n', 'g'), '\n')
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using >+.
 */
export class FoldedKeepBlockChomping implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '>' && raw.charAt(1) != '+') throw new Error("Illegal argument: Must begin with >+")
        if (raw.charAt(2) != '\n') throw new Error("Illegal argument: Must begin with >+\n")
        let index = 3
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(3)
    }

    text() {
        let raw = this.node.value();
        let newlines = raw.match(new RegExp('\n+$'))
        return raw.substr(this.leading.length)
                .replace(new RegExp('^' + this.indent, 'mg'), '')
                .replace(new RegExp('\n+$'), '')
                .replace(new RegExp('([^\n])\n([^\n])', 'g'), '$1 $2')
                .replace(new RegExp('\n\n', 'g'), '\n')
                + newlines[0].toString()
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using |. Maintain newlines.
 */
export class LiteralBlockScalar implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '|') throw new Error("Illegal argument: Must begin with |")
        if (raw.charAt(1) != '\n') throw new Error("Illegal argument: Must begin with |\n")
        let index = 2
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(2)
    }

    text() {
        return this.node.value().substr(this.leading.length)
            .replace(new RegExp('^' + this.indent, 'mg'), '')
            .replace(new RegExp('\n+$'), '\n')
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using |-.
 */
export class LiteralStripBlockChomping implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '|' && raw.charAt(1) != '-') throw new Error("Illegal argument: Must begin with |-")
        if (raw.charAt(2) != '\n') throw new Error("Illegal argument: Must begin with |-\n")
        let index = 3
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(3)
    }

    text() {
        return this.node.value().substr(this.leading.length)
            .replace(new RegExp('^' + this.indent, 'mg'), '')
            .replace(new RegExp('\n+$'), '')
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using |+.
 */
export class LiteralKeepBlockChomping implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '|' && raw.charAt(1) != '+') throw new Error("Illegal argument: Must begin with |+")
        if (raw.charAt(2) != '\n') throw new Error("Illegal argument: Must begin with |+\n")
        let index = 3
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(3)
    }

    text() {
        let raw = this.node.value();
        let newlines = raw.match(new RegExp('\n+$'))
        return raw.substr(this.leading.length)
            .replace(new RegExp('^' + this.indent, 'mg'), '')
            .replace(new RegExp('\n+$'), '')
            + newlines[0].toString()
    }
    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        // console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * Works with raw node value to add and remove sequence elements, observing YAML formatting.
 */
export class SequenceOps {

    private items: String[]

    constructor(private node: TextTreeNode) {
        this.items = node.value().trim().split('\n')
    }

    addElement(elem: string) {
        this.items.push('- ' + elem)
        let newValue = this.items.join('\n') + '\n'
        this.node.update(newValue)
        // console.log(this.node.value())
    }

    removeElement(elem: string) {
        let index = this.items.indexOf('- ' + elem)
        if (index > -1) {
            this.items.splice(index, 1)
            let newValue = this.items.join('\n') + '\n'
            this.node.update(newValue)
            // console.log(this.node.value())
        }
    }
}

export type Sequence = SequenceOps & TextTreeNode
